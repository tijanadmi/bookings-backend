// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: reservation.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const allNewReservations = `-- name: AllNewReservations :many
select r.id as reservation_id,rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, r.num_nights, r.num_guests, r.status, r.total_price, r.extras_price, r.is_paid, r.has_breakfast,
rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
where processed = 0
order by r.start_date asc
LIMIT $1
OFFSET $2
`

type AllNewReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type AllNewReservationsRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	NumNights       pgtype.Int4 `json:"num_nights"`
	NumGuests       pgtype.Int4 `json:"num_guests"`
	Status          string      `json:"status"`
	TotalPrice      pgtype.Int4 `json:"total_price"`
	ExtrasPrice     int32       `json:"extras_price"`
	IsPaid          bool        `json:"is_paid"`
	HasBreakfast    bool        `json:"has_breakfast"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) AllNewReservations(ctx context.Context, arg AllNewReservationsParams) ([]AllNewReservationsRow, error) {
	rows, err := q.db.Query(ctx, allNewReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AllNewReservationsRow{}
	for rows.Next() {
		var i AllNewReservationsRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.RoomGuestNumber,
			&i.RoomPriceEn,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.RoomID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Processed,
			&i.NumNights,
			&i.NumGuests,
			&i.Status,
			&i.TotalPrice,
			&i.ExtrasPrice,
			&i.IsPaid,
			&i.HasBreakfast,
			&i.RoomNameSr,
			&i.RoomNameEn,
			&i.RoomNameBg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allProcessedReservations = `-- name: AllProcessedReservations :many
select r.id as reservation_id,rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed,r.num_nights, r.num_guests, r.status, r.total_price, r.extras_price, r.is_paid, r.has_breakfast,
rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
where processed = 1
order by r.start_date asc
LIMIT $1
OFFSET $2
`

type AllProcessedReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type AllProcessedReservationsRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	NumNights       pgtype.Int4 `json:"num_nights"`
	NumGuests       pgtype.Int4 `json:"num_guests"`
	Status          string      `json:"status"`
	TotalPrice      pgtype.Int4 `json:"total_price"`
	ExtrasPrice     int32       `json:"extras_price"`
	IsPaid          bool        `json:"is_paid"`
	HasBreakfast    bool        `json:"has_breakfast"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) AllProcessedReservations(ctx context.Context, arg AllProcessedReservationsParams) ([]AllProcessedReservationsRow, error) {
	rows, err := q.db.Query(ctx, allProcessedReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AllProcessedReservationsRow{}
	for rows.Next() {
		var i AllProcessedReservationsRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.RoomGuestNumber,
			&i.RoomPriceEn,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.RoomID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Processed,
			&i.NumNights,
			&i.NumGuests,
			&i.Status,
			&i.TotalPrice,
			&i.ExtrasPrice,
			&i.IsPaid,
			&i.HasBreakfast,
			&i.RoomNameSr,
			&i.RoomNameEn,
			&i.RoomNameBg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allReservations = `-- name: AllReservations :many
select r.id as reservation_id, rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, r.num_nights, r.num_guests, r.status, r.total_price, r.extras_price, r.is_paid, r.has_breakfast,
rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
order by r.start_date asc
LIMIT $1
OFFSET $2
`

type AllReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type AllReservationsRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	NumNights       pgtype.Int4 `json:"num_nights"`
	NumGuests       pgtype.Int4 `json:"num_guests"`
	Status          string      `json:"status"`
	TotalPrice      pgtype.Int4 `json:"total_price"`
	ExtrasPrice     int32       `json:"extras_price"`
	IsPaid          bool        `json:"is_paid"`
	HasBreakfast    bool        `json:"has_breakfast"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) AllReservations(ctx context.Context, arg AllReservationsParams) ([]AllReservationsRow, error) {
	rows, err := q.db.Query(ctx, allReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AllReservationsRow{}
	for rows.Next() {
		var i AllReservationsRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.RoomGuestNumber,
			&i.RoomPriceEn,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.RoomID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Processed,
			&i.NumNights,
			&i.NumGuests,
			&i.Status,
			&i.TotalPrice,
			&i.ExtrasPrice,
			&i.IsPaid,
			&i.HasBreakfast,
			&i.RoomNameSr,
			&i.RoomNameEn,
			&i.RoomNameBg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (
	room_id,
	first_name,
	last_name,
	email,
	phone,
	start_date,
	end_date,
	processed,
  num_nights,
  num_guests,
  status,
  total_price,
  extras_price,
  is_paid,
  has_breakfast
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at, num_nights, num_guests, status, total_price, extras_price, is_paid, has_breakfast
`

type CreateReservationParams struct {
	RoomID       int32       `json:"room_id"`
	FirstName    string      `json:"first_name"`
	LastName     string      `json:"last_name"`
	Email        string      `json:"email"`
	Phone        string      `json:"phone"`
	StartDate    time.Time   `json:"start_date"`
	EndDate      time.Time   `json:"end_date"`
	Processed    int32       `json:"processed"`
	NumNights    pgtype.Int4 `json:"num_nights"`
	NumGuests    pgtype.Int4 `json:"num_guests"`
	Status       string      `json:"status"`
	TotalPrice   pgtype.Int4 `json:"total_price"`
	ExtrasPrice  int32       `json:"extras_price"`
	IsPaid       bool        `json:"is_paid"`
	HasBreakfast bool        `json:"has_breakfast"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, createReservation,
		arg.RoomID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.StartDate,
		arg.EndDate,
		arg.Processed,
		arg.NumNights,
		arg.NumGuests,
		arg.Status,
		arg.TotalPrice,
		arg.ExtrasPrice,
		arg.IsPaid,
		arg.HasBreakfast,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumNights,
		&i.NumGuests,
		&i.Status,
		&i.TotalPrice,
		&i.ExtrasPrice,
		&i.IsPaid,
		&i.HasBreakfast,
	)
	return i, err
}

const deleteReservation = `-- name: DeleteReservation :exec
DELETE FROM reservations
WHERE id = $1
`

func (q *Queries) DeleteReservation(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteReservation, id)
	return err
}

const getReservation = `-- name: GetReservation :one
SELECT id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at, num_nights, num_guests, status, total_price, extras_price, is_paid, has_breakfast FROM reservations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetReservation(ctx context.Context, id int32) (Reservation, error) {
	row := q.db.QueryRow(ctx, getReservation, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumNights,
		&i.NumGuests,
		&i.Status,
		&i.TotalPrice,
		&i.ExtrasPrice,
		&i.IsPaid,
		&i.HasBreakfast,
	)
	return i, err
}

const getReservationByID = `-- name: GetReservationByID :one
select r.id as reservation_id,rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, r.num_nights, r.num_guests, r.status, r.total_price, r.extras_price, r.is_paid, r.has_breakfast,
rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
where r.id = $1
order by r.start_date asc
`

type GetReservationByIDRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	NumNights       pgtype.Int4 `json:"num_nights"`
	NumGuests       pgtype.Int4 `json:"num_guests"`
	Status          string      `json:"status"`
	TotalPrice      pgtype.Int4 `json:"total_price"`
	ExtrasPrice     int32       `json:"extras_price"`
	IsPaid          bool        `json:"is_paid"`
	HasBreakfast    bool        `json:"has_breakfast"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) GetReservationByID(ctx context.Context, id int32) (GetReservationByIDRow, error) {
	row := q.db.QueryRow(ctx, getReservationByID, id)
	var i GetReservationByIDRow
	err := row.Scan(
		&i.ReservationID,
		&i.RoomGuestNumber,
		&i.RoomPriceEn,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.RoomID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Processed,
		&i.NumNights,
		&i.NumGuests,
		&i.Status,
		&i.TotalPrice,
		&i.ExtrasPrice,
		&i.IsPaid,
		&i.HasBreakfast,
		&i.RoomNameSr,
		&i.RoomNameEn,
		&i.RoomNameBg,
	)
	return i, err
}

const getReservationForUpdate = `-- name: GetReservationForUpdate :one
SELECT id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at, num_nights, num_guests, status, total_price, extras_price, is_paid, has_breakfast FROM reservations
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetReservationForUpdate(ctx context.Context, id int32) (Reservation, error) {
	row := q.db.QueryRow(ctx, getReservationForUpdate, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumNights,
		&i.NumGuests,
		&i.Status,
		&i.TotalPrice,
		&i.ExtrasPrice,
		&i.IsPaid,
		&i.HasBreakfast,
	)
	return i, err
}

const listReservations = `-- name: ListReservations :many
SELECT id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at, num_nights, num_guests, status, total_price, extras_price, is_paid, has_breakfast FROM reservations
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListReservations(ctx context.Context, arg ListReservationsParams) ([]Reservation, error) {
	rows, err := q.db.Query(ctx, listReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.Processed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumNights,
			&i.NumGuests,
			&i.Status,
			&i.TotalPrice,
			&i.ExtrasPrice,
			&i.IsPaid,
			&i.HasBreakfast,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsAfterDate = `-- name: ListReservationsAfterDate :many
select r.id as reservation_id, rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, r.num_nights, r.num_guests, r.status, r.total_price, r.extras_price, r.is_paid, r.has_breakfast,
rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
where r.created_at::date BETWEEN $1 AND  $2
order by r.start_date asc
`

type ListReservationsAfterDateParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type ListReservationsAfterDateRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	NumNights       pgtype.Int4 `json:"num_nights"`
	NumGuests       pgtype.Int4 `json:"num_guests"`
	Status          string      `json:"status"`
	TotalPrice      pgtype.Int4 `json:"total_price"`
	ExtrasPrice     int32       `json:"extras_price"`
	IsPaid          bool        `json:"is_paid"`
	HasBreakfast    bool        `json:"has_breakfast"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) ListReservationsAfterDate(ctx context.Context, arg ListReservationsAfterDateParams) ([]ListReservationsAfterDateRow, error) {
	rows, err := q.db.Query(ctx, listReservationsAfterDate, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsAfterDateRow{}
	for rows.Next() {
		var i ListReservationsAfterDateRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.RoomGuestNumber,
			&i.RoomPriceEn,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.RoomID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Processed,
			&i.NumNights,
			&i.NumGuests,
			&i.Status,
			&i.TotalPrice,
			&i.ExtrasPrice,
			&i.IsPaid,
			&i.HasBreakfast,
			&i.RoomNameSr,
			&i.RoomNameEn,
			&i.RoomNameBg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaysAfterDate = `-- name: ListStaysAfterDate :many
select r.id as reservation_id, rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, r.num_nights, r.num_guests, r.status, r.total_price, r.extras_price, r.is_paid, r.has_breakfast,
rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
where r.start_date::date BETWEEN $1 AND  $2
order by r.start_date asc
`

type ListStaysAfterDateParams struct {
	StartDate   time.Time `json:"start_date"`
	StartDate_2 time.Time `json:"start_date_2"`
}

type ListStaysAfterDateRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	NumNights       pgtype.Int4 `json:"num_nights"`
	NumGuests       pgtype.Int4 `json:"num_guests"`
	Status          string      `json:"status"`
	TotalPrice      pgtype.Int4 `json:"total_price"`
	ExtrasPrice     int32       `json:"extras_price"`
	IsPaid          bool        `json:"is_paid"`
	HasBreakfast    bool        `json:"has_breakfast"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) ListStaysAfterDate(ctx context.Context, arg ListStaysAfterDateParams) ([]ListStaysAfterDateRow, error) {
	rows, err := q.db.Query(ctx, listStaysAfterDate, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStaysAfterDateRow{}
	for rows.Next() {
		var i ListStaysAfterDateRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.RoomGuestNumber,
			&i.RoomPriceEn,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.RoomID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Processed,
			&i.NumNights,
			&i.NumGuests,
			&i.Status,
			&i.TotalPrice,
			&i.ExtrasPrice,
			&i.IsPaid,
			&i.HasBreakfast,
			&i.RoomNameSr,
			&i.RoomNameEn,
			&i.RoomNameBg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodayActivity = `-- name: ListTodayActivity :many
select r.id as reservation_id, rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, r.num_nights, r.num_guests, r.status, r.total_price, r.extras_price, r.is_paid, r.has_breakfast,
rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
 where (r.status = 'unconfirmed' AND r.start_date::date =$1)
    OR 
    (r.status = 'checked-in' AND r.end_date::date =$2)
order by r.start_date asc
`

type ListTodayActivityParams struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

type ListTodayActivityRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	NumNights       pgtype.Int4 `json:"num_nights"`
	NumGuests       pgtype.Int4 `json:"num_guests"`
	Status          string      `json:"status"`
	TotalPrice      pgtype.Int4 `json:"total_price"`
	ExtrasPrice     int32       `json:"extras_price"`
	IsPaid          bool        `json:"is_paid"`
	HasBreakfast    bool        `json:"has_breakfast"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) ListTodayActivity(ctx context.Context, arg ListTodayActivityParams) ([]ListTodayActivityRow, error) {
	rows, err := q.db.Query(ctx, listTodayActivity, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTodayActivityRow{}
	for rows.Next() {
		var i ListTodayActivityRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.RoomGuestNumber,
			&i.RoomPriceEn,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.RoomID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Processed,
			&i.NumNights,
			&i.NumGuests,
			&i.Status,
			&i.TotalPrice,
			&i.ExtrasPrice,
			&i.IsPaid,
			&i.HasBreakfast,
			&i.RoomNameSr,
			&i.RoomNameEn,
			&i.RoomNameBg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProcessedForReservation = `-- name: UpdateProcessedForReservation :one
UPDATE reservations
SET
  processed = $1
WHERE
id = $2
RETURNING id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at, num_nights, num_guests, status, total_price, extras_price, is_paid, has_breakfast
`

type UpdateProcessedForReservationParams struct {
	Processed int32 `json:"processed"`
	ID        int32 `json:"id"`
}

func (q *Queries) UpdateProcessedForReservation(ctx context.Context, arg UpdateProcessedForReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, updateProcessedForReservation, arg.Processed, arg.ID)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumNights,
		&i.NumGuests,
		&i.Status,
		&i.TotalPrice,
		&i.ExtrasPrice,
		&i.IsPaid,
		&i.HasBreakfast,
	)
	return i, err
}

const updateReservation = `-- name: UpdateReservation :one
UPDATE reservations
SET
  updated_at = COALESCE($1, updated_at),
  room_id = COALESCE($2, room_id),
  first_name = COALESCE($3, first_name),
  last_name = COALESCE($4, last_name),
  email = COALESCE($5, email),
  phone = COALESCE($6, phone),
  start_date = COALESCE($7, start_date),
  end_date = COALESCE($8, end_date),
  processed = COALESCE($9, processed),
  num_nights = COALESCE($10, num_nights),
  num_guests = COALESCE($11, num_guests),
  status = COALESCE($12, status),
  total_price = COALESCE($13, total_price),
  extras_price = COALESCE($14, extras_price),
  is_paid = COALESCE($15, is_paid),
  has_breakfast = COALESCE($16, has_breakfast)
WHERE
id = $17
RETURNING id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at, num_nights, num_guests, status, total_price, extras_price, is_paid, has_breakfast
`

type UpdateReservationParams struct {
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	RoomID       pgtype.Int4        `json:"room_id"`
	FirstName    pgtype.Text        `json:"first_name"`
	LastName     pgtype.Text        `json:"last_name"`
	Email        pgtype.Text        `json:"email"`
	Phone        pgtype.Text        `json:"phone"`
	StartDate    pgtype.Date        `json:"start_date"`
	EndDate      pgtype.Date        `json:"end_date"`
	Processed    pgtype.Int4        `json:"processed"`
	NumNights    pgtype.Int4        `json:"num_nights"`
	NumGuests    pgtype.Int4        `json:"num_guests"`
	Status       pgtype.Text        `json:"status"`
	TotalPrice   pgtype.Int4        `json:"total_price"`
	ExtrasPrice  pgtype.Int4        `json:"extras_price"`
	IsPaid       pgtype.Bool        `json:"is_paid"`
	HasBreakfast pgtype.Bool        `json:"has_breakfast"`
	ID           int32              `json:"id"`
}

func (q *Queries) UpdateReservation(ctx context.Context, arg UpdateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, updateReservation,
		arg.UpdatedAt,
		arg.RoomID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.StartDate,
		arg.EndDate,
		arg.Processed,
		arg.NumNights,
		arg.NumGuests,
		arg.Status,
		arg.TotalPrice,
		arg.ExtrasPrice,
		arg.IsPaid,
		arg.HasBreakfast,
		arg.ID,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumNights,
		&i.NumGuests,
		&i.Status,
		&i.TotalPrice,
		&i.ExtrasPrice,
		&i.IsPaid,
		&i.HasBreakfast,
	)
	return i, err
}
