// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: reservation.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const allNewReservations = `-- name: AllNewReservations :many
select r.id as reservation_id,rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
where processed = 0
order by r.start_date asc
LIMIT $1
OFFSET $2
`

type AllNewReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type AllNewReservationsRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) AllNewReservations(ctx context.Context, arg AllNewReservationsParams) ([]AllNewReservationsRow, error) {
	rows, err := q.db.Query(ctx, allNewReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AllNewReservationsRow{}
	for rows.Next() {
		var i AllNewReservationsRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.RoomGuestNumber,
			&i.RoomPriceEn,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.RoomID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Processed,
			&i.RoomNameSr,
			&i.RoomNameEn,
			&i.RoomNameBg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allProcessedReservations = `-- name: AllProcessedReservations :many
select r.id as reservation_id,rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
where processed = 1
order by r.start_date asc
LIMIT $1
OFFSET $2
`

type AllProcessedReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type AllProcessedReservationsRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) AllProcessedReservations(ctx context.Context, arg AllProcessedReservationsParams) ([]AllProcessedReservationsRow, error) {
	rows, err := q.db.Query(ctx, allProcessedReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AllProcessedReservationsRow{}
	for rows.Next() {
		var i AllProcessedReservationsRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.RoomGuestNumber,
			&i.RoomPriceEn,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.RoomID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Processed,
			&i.RoomNameSr,
			&i.RoomNameEn,
			&i.RoomNameBg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allReservations = `-- name: AllReservations :many
select r.id as reservation_id, rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
order by r.start_date asc
LIMIT $1
OFFSET $2
`

type AllReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type AllReservationsRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) AllReservations(ctx context.Context, arg AllReservationsParams) ([]AllReservationsRow, error) {
	rows, err := q.db.Query(ctx, allReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AllReservationsRow{}
	for rows.Next() {
		var i AllReservationsRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.RoomGuestNumber,
			&i.RoomPriceEn,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.RoomID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Processed,
			&i.RoomNameSr,
			&i.RoomNameEn,
			&i.RoomNameBg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (
	room_id,
	first_name,
	last_name,
	email,
	phone,
	start_date,
	end_date,
	processed
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at
`

type CreateReservationParams struct {
	RoomID    int32     `json:"room_id"`
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	Email     string    `json:"email"`
	Phone     string    `json:"phone"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
	Processed int32     `json:"processed"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, createReservation,
		arg.RoomID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.StartDate,
		arg.EndDate,
		arg.Processed,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReservation = `-- name: DeleteReservation :exec
DELETE FROM reservations
WHERE id = $1
`

func (q *Queries) DeleteReservation(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteReservation, id)
	return err
}

const getReservation = `-- name: GetReservation :one
SELECT id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at FROM reservations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetReservation(ctx context.Context, id int32) (Reservation, error) {
	row := q.db.QueryRow(ctx, getReservation, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReservationByID = `-- name: GetReservationByID :one
select r.id as reservation_id,rm.room_guest_number, rm.room_price_en, r.first_name, r.last_name, r.email, r.phone, r.start_date, 
r.end_date, r.room_id , r.created_at, r.updated_at, r.processed, rm.room_name_sr,
rm.room_name_en,
rm.room_name_bg
from reservations r
left join rooms rm on (r.room_id = rm.id)
where r.id = $1
order by r.start_date asc
LIMIT $2
OFFSET $3
`

type GetReservationByIDParams struct {
	ID     int32 `json:"id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetReservationByIDRow struct {
	ReservationID   int32       `json:"reservation_id"`
	RoomGuestNumber pgtype.Int4 `json:"room_guest_number"`
	RoomPriceEn     pgtype.Int4 `json:"room_price_en"`
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Phone           string      `json:"phone"`
	StartDate       time.Time   `json:"start_date"`
	EndDate         time.Time   `json:"end_date"`
	RoomID          int32       `json:"room_id"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Processed       int32       `json:"processed"`
	RoomNameSr      pgtype.Text `json:"room_name_sr"`
	RoomNameEn      pgtype.Text `json:"room_name_en"`
	RoomNameBg      pgtype.Text `json:"room_name_bg"`
}

func (q *Queries) GetReservationByID(ctx context.Context, arg GetReservationByIDParams) (GetReservationByIDRow, error) {
	row := q.db.QueryRow(ctx, getReservationByID, arg.ID, arg.Limit, arg.Offset)
	var i GetReservationByIDRow
	err := row.Scan(
		&i.ReservationID,
		&i.RoomGuestNumber,
		&i.RoomPriceEn,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.RoomID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Processed,
		&i.RoomNameSr,
		&i.RoomNameEn,
		&i.RoomNameBg,
	)
	return i, err
}

const getReservationForUpdate = `-- name: GetReservationForUpdate :one
SELECT id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at FROM reservations
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetReservationForUpdate(ctx context.Context, id int32) (Reservation, error) {
	row := q.db.QueryRow(ctx, getReservationForUpdate, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listReservations = `-- name: ListReservations :many
SELECT id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at FROM reservations
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListReservations(ctx context.Context, arg ListReservationsParams) ([]Reservation, error) {
	rows, err := q.db.Query(ctx, listReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.StartDate,
			&i.EndDate,
			&i.Processed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProcessedForReservation = `-- name: UpdateProcessedForReservation :one
UPDATE reservations
SET
  processed = $1
WHERE
id = $2
RETURNING id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at
`

type UpdateProcessedForReservationParams struct {
	Processed int32 `json:"processed"`
	ID        int32 `json:"id"`
}

func (q *Queries) UpdateProcessedForReservation(ctx context.Context, arg UpdateProcessedForReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, updateProcessedForReservation, arg.Processed, arg.ID)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReservation = `-- name: UpdateReservation :one
UPDATE reservations
SET
  updated_at = COALESCE($1, updated_at),
  room_id = COALESCE($2, room_id),
  first_name = COALESCE($3, first_name),
  last_name = COALESCE($4, last_name),
  email = COALESCE($5, email),
  phone = COALESCE($6, phone),
  start_date = COALESCE($7, start_date),
  end_date = COALESCE($8, end_date),
  processed = COALESCE($9, processed)
WHERE
id = $10
RETURNING id, room_id, first_name, last_name, email, phone, start_date, end_date, processed, created_at, updated_at
`

type UpdateReservationParams struct {
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	RoomID    pgtype.Int4        `json:"room_id"`
	FirstName pgtype.Text        `json:"first_name"`
	LastName  pgtype.Text        `json:"last_name"`
	Email     pgtype.Text        `json:"email"`
	Phone     pgtype.Text        `json:"phone"`
	StartDate pgtype.Date        `json:"start_date"`
	EndDate   pgtype.Date        `json:"end_date"`
	Processed pgtype.Int4        `json:"processed"`
	ID        int32              `json:"id"`
}

func (q *Queries) UpdateReservation(ctx context.Context, arg UpdateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, updateReservation,
		arg.UpdatedAt,
		arg.RoomID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.StartDate,
		arg.EndDate,
		arg.Processed,
		arg.ID,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.StartDate,
		&i.EndDate,
		&i.Processed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
